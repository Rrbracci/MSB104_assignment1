---
title: "MSB104_assignment1"
author: "Rrbracci & AGaard01"
format: html
editor: visual
bibliography: [MSB104_Assignment1.bib]
---

```{r}
#| label: setup
#| output: false
#| message: false
#| echo: false
library(eurostat)
library(dineq)
library(tidyverse)
library(gridExtra)
library(modelr)
library(grid)
library(ggplotify)
library(vtable)
library(dplyr)
library(dineq)
```

# Sub-national GDP and GDP per Capita

## **Data Acquisition**

### Population per sub-region in DE, FI & RO

```{r}
#| echo: false
# Downloaded file for population in DE (Germany), FI (Finland) and RO (Romania). Furthermore, we load up the file i RStudio by import the file in Library(readr). Moreover, we commended RStudio to read the file "demo_r_pjanaggr3_page_linear_csv". Additionally, we implemented the function na = "NA" for RStudio to read the missing values. Lastly, we added the function "show_col_types = FALSE" to prevent RStudio displaying the column data types while reading the file. 
library(readr)
demo_r_pjanaggr3_page_linear_csv <- read_csv("demo_r_pjanaggr3_page_linear.csv.gz", 
    na = "NA", show_col_types = FALSE)
```

```{r}
#| echo: false
# First step was to rename the file for the assigned countries (DE, FI & RO). Furthermore, we utilized the function filter with str_sub considering a better overview of relevant dataset. Lastly, we were interested in population in every sub_regionals in the relevant contries. To receive and organise the relevant data, the function "Select" was used.  
DE_FI_RO_pop <- demo_r_pjanaggr3_page_linear_csv |>
	filter(str_sub
	       (geo, start = 1L, end = 2L) %in% c("DE", "FI", "RO")) |>
	select(Year = TIME_PERIOD, Sub_regions = geo, Population = OBS_VALUE)
```

```{r}
#| echo: false
#| paged.print: false
# Table with overview of population per region in the countries of Germany, Finland and Romania.
DE_FI_RO_pop |> 
  print(
    n = 5 ,
    width = 100 ,
    )
```

## GDP per sub-region in DE, FI & RO

```{r}
#| echo: false
# Downloaded file for GDP in DE (Germany), FI (Finland) and RO (Romania). Furthermore, we load up the file i RStudio by import the file in Library(readr). Moreover, we commended RStudio to read the file "nama_10r_3gdp_page_linear_csv". Additionally, we implemented the function na = "NA" for RStudio to read the missing values. Lastly, we added the function "show_col_types = FALSE" to prevent RStudio displaying the column data types while reading the file. 
library(readr)
nama_10r_3gdp_page_linear_csv <- read_csv("nama_10r_3gdp_page_linear.csv.gz", 
    na = "NA", show_col_types = FALSE)
```

```{r}
#| echo: false
# First step was to rename the file for the assigned countries (DE, FI & RO). Furthermore, we utilized the function filter with str_sub considering a better overview of relevant dataset. Lastly, we were interested in population in every sub_regionals in the relevant contries. To receive and organise the relevant data, the function "Select" was used.  
DE_FI_RO_gdp <- nama_10r_3gdp_page_linear_csv |>
	filter(str_sub
	       (geo, start = 1L, end = 2L) %in% c("DE", "FI", "RO")) |>
	select(Year = TIME_PERIOD, Sub_regions = geo, GDP = OBS_VALUE)
```

```{r}
#| echo: false
#| paged.print: false
# Table with overview of GPD per region in the countries of Germany, Finland and Romania.
DE_FI_RO_gdp |> 
  print(
    n = 5 ,
    width = 100 ,
    )
```

### Overview of presented datasets and structure

The first dataset we downloaded from Eurostat was **demo_r_pjanaggr3,** which contains population data from Europe.
In our case, we have selected population data from Finland, Germany and Romania.
According to @eurostat2021, the dataset of demography is a set of statistical numbers each country in Europe sends yearly to Eurostat by 31 December of the following calendar year.
Furthermore, the definition of "population" is, according to @eurostat2021, all persons having their residences in a member state, including all live births and deaths during the year when the statistical numbers are heading to Eurostat.
Moreover, the demographic data at a regional level are separated into different groups named NUTS, which are defined as nomenclature for territorial units for statistics [@eurostat2021].
The purpose of the NUTS function is to subdivide the territory of the European Union into 104 regions at NUTS level 1 and break it down by to 281 at NUTS level 2 and 1348 at NUTS level 3 [@eurostat2021].
In this paper, we have focused on the numbers of NUTS 3 level, but the dataset containing population data has been broken down by sex and broad age groups (0-14, 15-64 and 65 or more).

The following dataset we downloaded from Eurostat was the **nama_10r_3gdp dataset**.
Furthermore, this dataset is also broken down to NUTS level 3 which focus on GDP data from the sub-regions in Finland, Germany and Romania.
According to @eurostat2023, GDP (Gross domsetsic product) at market prices is defined as the final result of the production activity of resident producer units [@eurostat2023].

## **GDP per Capita Calculation**

```{r}
#| echo: false
# Merging data
merged_data <- merge(DE_FI_RO_pop, DE_FI_RO_gdp) 
```

```{r}
#| echo: false
# Step one: choose dataset for transformation. 
# Step two: mutate and create new column (GDP_per_capita)
merged_data <- merged_data |> 
  mutate(
    GDP_per_capita = 1000000 * GDP/Population
    )
```

```{r}
#| echo: false
# Creating new dataset only containing population, GDP and GDP per capita
merged_data_GDP_PC <- merged_data %>%
  select(Population, GDP, GDP_per_capita)
```

```{r}
#| echo: false
# Summary for viewing the new dataset. 
summary(merged_data_GDP_PC) 
```

### Calculation steps

![](images/387521025_674930251254296_7967018015334033524_n.png){fig-alt="Formula of GDP per capita"}

The first step in calculating GDP per capita for each sub-region, was to merge the two datasets of GDP and population.
We named the new dataset merged_data.
Furthermore, we started with transforming the new dataset by creating a new column called GDP_per_capita.
We calculated GDP per capita by using the formula GDP divided by Population, but to view more presentable numbers, we multiplied the formula with 1 000 000 since we want to provide GDP per capita in million EURO.
Lastly, we created a another new dataset called merged_data_GDP_PC and provided the summary function to get an overview of various summary statistics and information for each column in the merged_data_GDP_PC dataset.

## Descriptive Analysis:

### Germany

```{r}
#| echo: false
# Created new dataset called GDP_DE_nuts2.
# Filtered sub-regions from Germany by using str_sub to extract a substring from the Sub_regions columns containing the letters DE for Germany.
# Creating new column called id_nuts2 to save the new data for calculating Gini coefficient, for presenting the numbers of regional inequity in Germany at NUTS2 level.
# Next step is to group the numbers of NUTS2 level sorted by the the code of the region in NUTS2 level and year.
# Finally summarise the Gini coefficient numbers of each German region in NUTS2 level by multiplying 1 000 000 with GDP divided by population. 
GDP_DE_nuts2 <- merged_data %>%
  filter(
    str_sub(Sub_regions, start = 1L, end = 2L) == "DE"
  ) |> 
  mutate(
    id_nuts2 = fct(str_sub(Sub_regions, start = 1L, end = 4L))
  ) |> 
  group_by(id_nuts2, Year) %>%
  summarise(
    GDP_per_capita_nuts2_DE = sum(1000000*GDP)/sum(Population)
    ) 
```

```{r}
#| echo: false
# Since Germany contains many regions, we have deceided to present them in two new values.
# DEz1North and DEz2SOUTH are the two values where we have devided Germany in South and North. 
# Created a combined value consisting of the Northern and Southern part of Germany.
DEz1NORTH <- c("DE30", "DE40", "DE50", "DE60", "DE80", "DE91", "DE92", "DE93", "DE94", "DEA1", "DEA2", "DEA3", "DEA4", "DEA5", "DEE0", "DEF0", "DEG0") 
DEz2SOUTH <- c("DE11", "DE12", "DE13", "DE14", "DE21", "DE22", "DE23", "DE24", "DE25", "DE26", "DE27", "DE71", "DE72", "DE73", "DEB1", "DEB2", "DEB3", "DEC0", "DED2", "DED4", "DED5")
DE <- c(DEz1NORTH, DEz2SOUTH)
```

```{r}
#| echo: false
# First step is to place the location of the figure caption and name it.
# Secondly, we filter GDP_DE_nuts2 to contain integer starting from 3 and ending with 4. Moreover, in this dataset we only contain vales larger or equal to 0, but less than 50.
# Thirdly, we represent the data in GPD_DE_nuts2 by mapping them in a plot using ggplot, where the x-axis represents year and y-axis represents GPD_per_capita. Furthermore the colour is determined by id_nuts2.
# Fourthly, we use geom_line since this gives a accurate description of our data from Germany.
#| cap-location: bottom
#| fig-cap: "GDP per year."
GDP_DE_nuts2 |>
  filter(
    id_nuts2 %in% DEz1NORTH
  ) |> 
  ggplot(mapping = aes(
    x = Year, 
    y = GDP_per_capita_nuts2_DE, 
    colour = id_nuts2)
    ) +
  geom_line()
```

```{r}
#| echo: false
# Duplicating the same steps for Southern Germany as for the Northern part. 
GDP_DE_nuts2 |>
  filter(
    id_nuts2 %in% DEz2SOUTH
  ) |> 
  ggplot(mapping = aes(
    x = Year, 
    y = GDP_per_capita_nuts2_DE, 
    colour = id_nuts2)
    ) +
  geom_line()
```

```{r}
#| echo: false
# Creating new dataset called desc_stat_DE_nuts2 and grouping it by year. 
# Using the summarise() function to summarize various statistics for each year. 
desc_stat_DE_nuts2 <- GDP_DE_nuts2 |> 
  group_by(Year) |> 
  summarise(
    min_GDP_each_year = min(GDP_per_capita_nuts2_DE),
    max_GDP_each_year = max(GDP_per_capita_nuts2_DE),
    median_GDP_each_year = median(GDP_per_capita_nuts2_DE),
    mean_GDP_each_year = mean(GDP_per_capita_nuts2_DE),
    sd_GDP_each_year = sd(GDP_per_capita_nuts2_DE),
    var_GDP_each_year = sd_GDP_each_year^2
  )
```

```{r}
#| echo: false
# To ensure the table do not contain previous grouping, we use the ungroup function. Moreover, we select desirable variable. Additional, the st fuction is utilised to compute summary statistics for the selected columns. Lastly, the summ-fuction specifies the summary statistics to calculate
GDP_DE_nuts2 |> 
  ungroup() |> 
  select(Year, GDP_pc = GDP_per_capita_nuts2_DE) |> 
  st(group = "Year", group.long = TRUE, 
     summ = c('notNA(x)','mean(x)', 'median(x)', 
              'sd(x)','min(x)','max(x)'),
     )
```

#### Description of the numbers from German sub-regions

In order to achieve a presentable figure showing GDP per year for the German sub-regions, we decided to divide the data into Northern and Southern Germany.
This prevented the data from becoming overly clustered and improved our ability to interpret the graphs.
The first figure presents data for North Germany, and the second figure presents data for South Germany.

In the figure presenting GDP per year for sub-regions in North Germany, we can observe one graph in particular on the top.
This graph also correspond to the max value seen in the table containing summary statistics.
This is the graph for region DE60, which is the code for Hamburg.
In 2000, Hamburg had a GDP per capita 45 659.50

2020:

DE60, Hamburg, 64 366.49

DE91, Braunschweig (Wolfsburg), 48 156.71

DE50, Bremen, 47 816.62

According to the datasets we used from Eurostat to calculate the GDP per capita, the sub-region in Germany with the highest GDP per capita was the sub-region coded DE913.
According to the report "Statistical regions in the European Union and partner countries NUTS and statistical regions 2021", this region is Wolfsburg, Kreisfreie Stadt **(SOURCE).** In 2019, each inhabitant stood for an economic output of about 196 010.74 euros.
Wolfsburg is the home of the car manufacturer group Volkswagen, which gives the local population job opportunities.
**Weernink (1997)** states that Volkswagen employees enjoy higher average wages, contributing to a higher GDP per capita, contributing to investment in education, infrastructure and health care, which enhances the overall quality of life for residents.
On the other hand, the sub-region with the lowest GDP per capita was Südwestpfalz (DEB3K).
This might be due to the limitation of industries that provide employees with high productivity or wages.
Another reasons can be income inequality, lack of investments (**SOURCE**)

**Gå gjennom outliers ved å bruke Espen sitt tilsendte dokument. F.eks. beskrive Wolfsbrug, Hamburg etc. Beskriv de laveste, si noe om hvorfor dette er tilfelle. Koble opp mot deskriptiv statistikk.**

**Si noe om finanskrisen og Covid i grafen.**

Remote or rural areas may have fewer economic opportunities and lower GDP per capita compared to urban centers.

Infrastructure and Education: Insufficient infrastructure and educational resources can hinder economic development.
Lack of access to quality education and transportation infrastructure can limit a region's ability to attract businesses and create high-paying jobs.

Income Inequality: Even if there are pockets of wealth in a region, high levels of income inequality can result in a low average GDP per capita.
This means that a significant portion of the population earns a relatively low income.

Government Policies: Government policies, taxation, and public investments can influence regional economic development.
Regions with supportive policies and investments in education, healthcare, and infrastructure tend to perform better economically.

Demographic Factors: The age and size of the population can also impact GDP per capita.
Regions with an aging population may have higher healthcare costs and lower labor force participation, affecting economic output.

Historical Factors: Historical events, such as wars or economic crises, can have long-lasting effects on a region's economy.
To understand the specific reasons behind Südwestpfalz's low GDP per capita, it would be necessary to conduct a detailed economic analysis and consider current economic conditions, local policies, and other relevant factors.
Local and regional governments, as well as economic development agencies, often work to address these challenges and promote economic growth in lower-income areas.

### Finland

```{r}
#| echo: false
# Created new dataset called GDP_FI_nuts2.
# Filtered sub-regions from Finland by using str_sub to extract a substring from the Sub_regions columns containing the letters FI for Finland
# Creating new column called id_nuts2 to save the new data for calculating Gini coefficient, for presenting the numbers of regional inequity in Finland at NUTS2 level.
# Next step is to group the numbers of NUTS2 level sorted by the the code of the region in NUTS2 level and year.
# Finally summarise the Gini coefficient numbers of each Finnish region in NUTS2 level by multiplying 1 000 000 with GDP divided by population. 
GDP_FI_nuts2 <- merged_data %>%
  filter(
    str_sub(Sub_regions, start = 1L, end = 2L) == "FI"
  ) |> 
  mutate(
    id_nuts2 = fct(str_sub(Sub_regions, start = 1L, end = 4L))
  ) |> 
  group_by(id_nuts2, Year) %>%
  summarise(
    GDP_per_capita_nuts2_FI = sum(1000000*GDP)/sum(Population)
    ) 
```

```{r}
#| echo: false
# First step is to place the location of the figure caption and name it.
# Secondly, we filter GDP_FI_nuts2 to contain integer starting from 3 and ending with 4. Moreover, in this dataset we only contain vales larger or equal to 0, but less than 50.
# Thirdly, we represent the data in GPD_FI_nuts2 by mapping them in a plot using ggplot, where the x-axis represents year and y-axis represents GPD_per_capita. Furthermore the colour is determined by id_nuts2.
# Fourthly, we use geom_line since this gives a accurate description of our data from Finland
#| cap-location: bottom
#| fig-cap: "GDP per year."
GDP_FI_nuts2 |>
  ggplot(mapping = aes(
    x = Year, 
    y = GDP_per_capita_nuts2_FI, 
    colour = id_nuts2)
    ) +
  geom_line()
```

```{r}
#| echo: false
# Creating new dataset called desc_stat_FI_nuts2 and grouping it by year. 
# Using the summarise() function to summarize various statistics for each year. 
desc_stat_FI_nuts2 <- GDP_FI_nuts2 |> 
  group_by(Year) |> 
  summarise(
    min_GDP_each_year = min(GDP_per_capita_nuts2_FI),
    max_GDP_each_year = max(GDP_per_capita_nuts2_FI),
    median_GDP_each_year = median(GDP_per_capita_nuts2_FI),
    mean_GDP_each_year = mean(GDP_per_capita_nuts2_FI),
    sd_GDP_each_year = sd(GDP_per_capita_nuts2_FI),
    var_GDP_each_year = sd_GDP_each_year^2
  )
```

```{r}
#| echo: false
# To ensure the table do not contain previous grouping, we use the ungroup function. Moreover, we select desirable variable. Additional, the st fuction is utilised to compute summary statistics for the selected columns. Lastly, the summ-fuction specifies the summary statistics to calculate
GDP_FI_nuts2 |> 
  ungroup() |> 
  select(Year, GDP_pc = GDP_per_capita_nuts2_FI) |> 
  st(group = "Year", group.long = TRUE, 
     summ = c('notNA(x)','mean(x)', 'median(x)', 
              'sd(x)','min(x)','max(x)'),
     )
```

### Romania

```{r}
#| echo: false
# Created new dataset called GDP_RO_nuts2.
# Filtered sub-regions from Romania by using str_sub to extract a substring from the Sub_regions columns containing the letters RO for Romania
# Creating new column called id_nuts2 to save the new data for calculating Gini coefficient, for presenting the numbers of regional inequity in Romania at NUTS2 level.
# Next step is to group the numbers of NUTS2 level sorted by the the code of the region in NUTS2 level and year.
# Finally summarise the Gini coefficient numbers of each Romanian region in NUTS2 level by multiplying 1 000 000 with GDP divided by population. 
GDP_RO_nuts2 <- merged_data %>%
  filter(
    str_sub(Sub_regions, start = 1L, end = 2L) == "RO"
  ) |> 
  mutate(
    id_nuts2 = fct(str_sub(Sub_regions, start = 1L, end = 4L))
  ) |> 
  group_by(id_nuts2, Year) %>%
  summarise(
    GDP_per_capita_nuts2_RO = sum(1000000*GDP)/sum(Population)
    ) 
```

```{r}
#| echo: false
# First step is to place the location of the figure caption and name it.
# Secondly, we filter GDP_RO_nuts2 to contain integer starting from 3 and ending with 4. Moreover, in this dataset we only contain vales larger or equal to 0, but less than 50.
# Thirdly, we represent the data in GPD_RO_nuts2 by mapping them in a plot using ggplot, where the x-axis represents year and y-axis represents GPD_per_capita. Furthermore the colour is determined by id_nuts2.
# Fourthly, we use geom_line since this gives a accurate description of our data from Romania
#| cap-location: bottom
#| fig-cap: "GDP per year."
GDP_RO_nuts2 |>
  ggplot(mapping = aes(
    x = Year, 
    y = GDP_per_capita_nuts2_RO, 
    colour = id_nuts2)
    ) +
  geom_line()
```

```{r}
#| echo: false
# Creating new dataset called desc_stat_RO_nuts2 and grouping it by year. 
# Using the summarise() function to summarize various statistics for each year. 
desc_stat_RO_nuts2 <- GDP_RO_nuts2 |> 
  group_by(Year) |> 
  summarise(
    min_GDP_each_year = min(GDP_per_capita_nuts2_RO),
    max_GDP_each_year = max(GDP_per_capita_nuts2_RO),
    median_GDP_each_year = median(GDP_per_capita_nuts2_RO),
    mean_GDP_each_year = mean(GDP_per_capita_nuts2_RO),
    sd_GDP_each_year = sd(GDP_per_capita_nuts2_RO),
    var_GDP_each_year = sd_GDP_each_year^2
  )
```

```{r}
#| echo: false
# To ensure the table do not contain previous grouping, we use the ungroup function. Moreover, we select desirable variable. Additional, the st fuction is utilised to compute summary statistics for the selected columns. Lastly, the summ-fuction specifies the summary statistics to calculate
GDP_RO_nuts2 |> 
  ungroup() |> 
  select(Year, GDP_pc = GDP_per_capita_nuts2_RO) |> 
  st(group = "Year", group.long = TRUE, 
     summ = c('notNA(x)','mean(x)', 'median(x)', 
              'sd(x)','min(x)','max(x)'),
     )
```

# Regional inequity

## Literature review

Regional inequality shows variation in regional GDP per capita, and according to @lessmann_and_seidel2017, regional inequality occurs when one region experiences different assumptions than other regions.
Moreover, when the level of economic development is high, there is significant regional inequality [@lessmann_and_seidel2017].
According to @williamson1965, one crucial difference that leads to regional inequality is the access to natural resources.
Regions rich in natural resources grow faster than regions in the rest of the country, which results in inequality.
Furthermore, openness is another critical element of why regional inequality occurs.
A region with more significant access to the international trade market than other regions with limited access will gain more from international trade if international trade costs decrease [@lessmann_and_seidel2017].

Moreover, openness can also contribute to foreign investors investing in a more attractive region, e.g., access to natural resources.
In the end, this led to an imbalance in regional equality.
Additionally, mobility can provide regional inequality through differences in transport costs from one region to another [@lessmann_and_seidel2017].
The differences in transport costs are caused, e.g. by fuel consumption per kilometre.
 

Furthermore, another significant element creating regional inequality is bureaucracy, policy and stability in a country [@lessmann_and_seidel2017].
Civil war affects the country's balance of regional equality and creates different assumptions.
An example is regions in a country that experience increasing aid.
Receiving assistance from foreign aid organisations creates inequality.
Lastly, @lessmann_and_seidel2017 state that an area where ethnic groups dominate as a minority can result in regional inequity.

Based on the research conducted by , considering regional inequities is essential since it can influence economic outcomes.
The research shows many examples of high- and low-income countries experiencing unbalanced regional development that results in income inequality [@lessmann_and_seidel2017].

## GINI Coefficient Calculation

```{r}
#| echo: false
# Creating two new columns in the dataset merged_data called id_nuts2 and id_nuts0. Secondly, extracting the first four characters of the Sub_regions column and assigns it to the new id_nuts2 column, as well as the first two characters and assigns them to the new id_nuts0 column. Lastly, remove grouping. 
merged_data <- merged_data %>%
  mutate(
    id_nuts2 = substr(Sub_regions,1,4),
    id_nuts0 = substr(Sub_regions,1,2)
    ) %>%
  ungroup()
# Creating new dataset called merged_temp and group the data by id_nuts2 and Year. Use mutate to calculate a new column called gini_n2 using the gini.wtd function, which compute a weighted Gini coefficient based on GDP per capita. Finally, remove grouping. 
merged_temp <- merged_data %>%
  group_by(id_nuts2, Year) %>%
  mutate(gini_n2 = gini.wtd(GDP_per_capita)) %>%
  ungroup()
```

```{r}
#| echo: false
# Creating two new columns called id_nuts2 and id_nuts0. Secondly, extracting the first four characters of the Sub_regions column and assigns it to the new id_nuts2 column, as well as the first two characters and assigns them to the new id_nuts0 column. Lastly, choosing columns to be retained listed within the select function.
merged_temp <- merged_temp %>%
  mutate(id_nuts2 = substr(Sub_regions, 1,4),
          id_nuts0 = substr(Sub_regions, 1,2)) %>%
  select(Year, Sub_regions, Population, GDP, GDP_per_capita, id_nuts0, id_nuts2, gini_n2)
```

To calculate the population-weighted Gini coefficient for GDP for each European NUTS2 level region within Germany, Finland and Romania, we used the data on the GDP and population for the different regions and associated countries.
The Gini coefficient measures income or wealth inequality within a population [@imfnd].
In this case, we want to calculate the Gini coefficient for GDP, which is a measure of economic inequality.
We calculated the Gini coefficient using the following formula:

![](images/387325388_332262946048979_5064907706589960466_n.png){fig-alt="Formula of GINI coefficient"}

We want to calculate the weighted average of the Gini coefficients based on the population of each region or country.
We do this by calculating a new column called gini_n2 using mutate, and applying the gini.wtd function, which compute a weighted Gini coefficient based on GDP per capita.

The population-weighted Gini coefficient provides a measure of economic inequality across all our regions and associated countries, taking into account their respective populations [@imfnd]. A Gini coefficient close to 0 indicates a more equal distribution of income or wealth among the population. In societies with low Gini coefficients, there is relatively less income or wealth inequality, and resources are more evenly distributed among individuals or households. These societies tend to have a larger middle class and fewer people living in poverty or extreme wealth [@imfnd]

A Gini coefficient close to 1 signifies a high level of income or wealth inequality.
In societies with high Gini coefficients, a significant portion of the income or wealth is concentrated among a small percentage of the population, leading to pronounced disparities.
These societies may have a large gap between the rich and the poor, with some individuals or households having substantially more resources than others [@imfnd].

The zero values occur as a result of regions like in Germany where the regions is actually an foreign embassy, army base or offshore energy prodution with no permanent residence.
This means they do not have any GDP per capita [@eurostat2021].

## Data presentation

### Germany

```{r}
#| echo: false
# Firstly, we create a new dataset called Gini_stat_DE_nuts2. 
# Secondly, we filter the data to include only rows where the id_nuts2 variable is in the DE group. 
# Thirdyly, after filtering, the data is grouped by the Year variable. This means that subsequent calculations will be performed separately for each year.
# Lastly, we use summarise to calculates summary statistics for the gini_n2 variable within each group (each year). 
Gini_stat_DE_nuts2 <- merged_temp %>%
  filter(id_nuts2 %in% DE) |> 
  group_by(Year) |> 
  summarise(
    min = min(gini_n2),
    max = max(gini_n2),
    median = median(gini_n2),
    mean = mean(gini_n2),
    sd = sd(gini_n2),
    var = sd^2
  )
```

```{r}
#| echo: false
# Firstly, we add a table caption. 
# Secondly, we remove grouping and then we add a new group containing year, min, max, median, mean, sd and var. 
# Thirdly, we use kable to create a create nicely formatted table.
#| tbl-cap: Descriptive statistics based on Gini coeffisient from NUTS2 level in Germany
Gini_stat_DE_nuts2 |> 
  ungroup() |> 
  select(Year, min, max, median, mean, sd, var) %>%
  kable(digits = 5)
```

```{r}
#| echo: false
# Firstly, we add a table caption at the bottom of the figure. 
# Secondly, we use the data from the dataset merged_temp and the function filter to ensure that the data we receive only represents Germany. 
# Thirdly, we use the function ggplot to presentate the Gini coefficient numbers from Germany in a geom_point. 
#| cap-location: bottom
#| fig-cap: "Gini nuts2 DE."
merged_temp |>
  filter(id_nuts2 %in% DE) |>
  ggplot(mapping = aes(
    x = Year, 
    y = gini_n2, 
    colour = id_nuts2)
    ) +
  geom_point()
```

### Finland

```{r}
#| echo: false
# Creating a new value containing the Gini coefficient numbers from the regions at NUTS2 level in Finland.  
FI <- c("FI19", "FI1B", "FI1C", "FI1D", "FI20")
```

```{r}
#| echo: false
# Firstly, we create a new dataset called Gini_stat_FI_nuts2. 
# Secondly, we filter the data to include only rows where the id_nuts2 variable is in the FI group. 
# Thirdyly, after filtering, the data is grouped by the Year variable. This means that subsequent calculations will be performed separately for each year.
# Lastly, we use summarise to calculates summary statistics for the gini_n2 variable within each group (each year).
Gini_stat_FI_nuts2 <- merged_temp %>%
  filter(id_nuts2 %in% FI) |> 
  group_by(Year) |> 
  summarise(
    min = min(gini_n2),
    max = max(gini_n2),
    median = median(gini_n2),
    mean = mean(gini_n2),
    sd = sd(gini_n2),
    var = sd^2
  )
```

```{r}
#| echo: false
# Firstly, we add a table caption. 
# Secondly, we remove grouping and then we add a new group containing year, min, max, median, mean, sd and var. 
# Thirdly, we use kable to create a create nicely formatted table.
#| tbl-cap: Descriptive statistics based on Gini coeffisient from NUTS2 level in Finland
Gini_stat_FI_nuts2 |> 
  ungroup() |> 
  select(Year, min, max, median, mean, sd, var) %>%
  kable(digits = 5)
```

```{r}
#| echo: false
# Firstly, we add a table caption at the bottom of the figure. 
# Secondly, we use the data from the dataset merged_temp and the function filter to ensure that the data we receive only represents Finland 
# Thirdly, we use the function ggplot to presentate the Gini coefficient numbers from Finland in a geom_point. 
#| cap-location: bottom
#| fig-cap: "Gini nuts2 FI."
merged_temp |>
  filter(id_nuts2 %in% FI) |>
  ggplot(mapping = aes(
    x = Year, 
    y = gini_n2, 
    colour = id_nuts2)
    ) +
  geom_point()
```

### Romania

```{r}
#| echo: false
# Creating a new value containing the Gini coefficient numbers from the regions at NUTS2 level in Romania  
RO <- c("RO11", "RO12", "RO21", "RO22", "RO31", "RO32", "RO41", "RO42")
```

```{r}
#| echo: false
# Firstly, we create a new dataset called Gini_stat_RO_nuts2. 
# Secondly, we filter the data to include only rows where the id_nuts2 variable is in the RO group. 
# Thirdyly, after filtering, the data is grouped by the Year variable. This means that subsequent calculations will be performed separately for each year.
# Lastly, we use summarise to calculates summary statistics for the gini_n2 variable within each group (each year).
Gini_stat_RO_nuts2 <- merged_temp %>%
  filter(id_nuts2 %in% RO) |> 
  group_by(Year) |> 
  summarise(
    min = min(gini_n2),
    max = max(gini_n2),
    median = median(gini_n2),
    mean = mean(gini_n2),
    sd = sd(gini_n2),
    var = sd^2
  )
```

```{r}
#| echo: false
# Firstly, we add a table caption. 
# Secondly, we remove grouping and then we add a new group containing year, min, max, median, mean, sd and var. 
# Thirdly, we use kable to create a create nicely formatted table.
#| tbl-cap: Descriptive statistics based on Gini coeffisient from NUTS2 level in Romania
Gini_stat_RO_nuts2 |> 
  ungroup() |> 
  select(Year, min, max, median, mean, sd, var) %>%
  kable(digits = 5)
```

```{r}
#| echo: false
# Firstly, we add a table caption at the bottom of the figure. 
# Secondly, we use the data from the dataset merged_temp and the function filter to ensure that the data we receive only represents Romania. 
# Thirdly, we use the function ggplot to presentate the Gini coefficient numbers from Romania in a geom_point. 
#| cap-location: bottom
#| fig-cap: "Gini nuts2 RO."
merged_temp |>
  filter(id_nuts2 %in% RO) |>
  ggplot(mapping = aes(
    x = Year, 
    y = gini_n2, 
    colour = id_nuts2)
    ) +
  geom_point()
```

## Discussion

```{r}
#| echo: false
# siste
```
