---
title: "MSB104_assignment1"
author: "Rrbracci & AGaard01"
format: html
editor: visual
bibliography: [MSB104_Assignment1.bib]
---

```{r}
#| label: setup
#| output: false
#| message: false
#| echo: false
library(eurostat)
library(dineq)
library(tidyverse)
library(gridExtra)
library(modelr)
library(grid)
library(ggplotify)
library(vtable)
library(dplyr)
library(dineq)
```

# Sub-national GDP and GDP per Capita

## **Data Acquisition**

### Population per sub-region in DE, FI & RO

```{r}
# Downloaded file for population in DE (Germany), FI (Finland) and RO (Romania). Furthermore, we load up the file i RStudio by import the file in Library(readr). Moreover, we commended RStudio to read the file "demo_r_pjanaggr3_page_linear_csv". Additionally, we implemented the function na = "NA" for RStudio to read the missing values. Lastly, we added the function "show_col_types = FALSE" to prevent RStudio displaying the column data types while reading the file. 
library(readr)
demo_r_pjanaggr3_page_linear_csv <- read_csv("demo_r_pjanaggr3_page_linear.csv.gz", 
    na = "NA", show_col_types = FALSE)
```

```{r}
# First step was to rename the file for the assigned countries (DE, FI & RO). Furthermore, we utilized the function filter with str_sub considering a better overview of relevant dataset. Lastly, we were interested in population in every sub_regionals in the relevant contries. To receive and organise the relevant data, the function "Select" was used.  
DE_FI_RO_pop <- demo_r_pjanaggr3_page_linear_csv |>
	filter(str_sub
	       (geo, start = 1L, end = 2L) %in% c("DE", "FI", "RO")) |>
	select(Year = TIME_PERIOD, Sub_regions = geo, Population = OBS_VALUE)
```

```{r}
#| paged.print: false
# Table with overview of population per region in the countries of Germany, Finland and Romania.
DE_FI_RO_pop |> 
  print(
    n = 5 ,
    width = 100 ,
    )
```

## GDP per sub-region in DE, FI & RO

```{r}
# Downloaded file for GDP in DE (Germany), FI (Finland) and RO (Romania). Furthermore, we load up the file i RStudio by import the file in Library(readr). Moreover, we commended RStudio to read the file "nama_10r_3gdp_page_linear_csv". Additionally, we implemented the function na = "NA" for RStudio to read the missing values. Lastly, we added the function "show_col_types = FALSE" to prevent RStudio displaying the column data types while reading the file. 
library(readr)
nama_10r_3gdp_page_linear_csv <- read_csv("nama_10r_3gdp_page_linear.csv.gz", 
    na = "NA", show_col_types = FALSE)
```

```{r}
# First step was to rename the file for the assigned countries (DE, FI & RO). Furthermore, we utilized the function filter with str_sub considering a better overview of relevant dataset. Lastly, we were interested in population in every sub_regionals in the relevant contries. To receive and organise the relevant data, the function "Select" was used.  
DE_FI_RO_gdp <- nama_10r_3gdp_page_linear_csv |>
	filter(str_sub
	       (geo, start = 1L, end = 2L) %in% c("DE", "FI", "RO")) |>
	select(Year = TIME_PERIOD, Sub_regions = geo, GDP = OBS_VALUE)
```

```{r}
#| paged.print: false
# Table with overview of GPD per region in the countries of Germany, Finland and Romania.
DE_FI_RO_gdp |> 
  print(
    n = 5 ,
    width = 100 ,
    )
```

### Overview of presented datasets and structure

The first dataset we downloaded from Eurostat was **demo_r_pjanaggr3,** which contains population data from Europe.
In our case, we have selected population data from Finland, Germany and Romania.
According to @eurostat2021, the dataset of demography is a set of statistical numbers each country in Europe sends yearly to Eurostat by 31 December of the following calendar year.
Furthermore, the definition of "population" is, according to @eurostat2021, all persons having their residences in a member state, including all live births and deaths during the year when the statistical numbers are heading to Eurostat.
Moreover, the demographic data at a regional level are separated into different groups named NUTS, which are defined as nomenclature for territorial units for statistics [@eurostat2021].
The purpose of the NUTS function is to subdivide the territory of the European Union into 104 regions at NUTS level 1 and break it down by to 281 at NUTS level 2 and 1348 at NUTS level 3 [@eurostat2021].
In this paper, we have focused on the numbers of NUTS 3 level, but the dataset containing population data has been broken down by sex and broad age groups (0-14, 15-64 and 65 or more).

The following dataset we downloaded from Eurostat was the **nama_10r_3gdp dataset**.
Furthermore, this dataset is also broken down to NUTS level 3 which focus on GDP data from the sub-regions in Finland, Germany and Romania.
According to @eurostat2023, GDP (Gross domsetsic product) at market prices is defined as the final result of the production activity of resident producer units [@eurostat2023].

## **GDP per Capita Calculation**

```{r}
# Merging data
merged_data <- merge(DE_FI_RO_pop, DE_FI_RO_gdp) 
```

```{r}
# Step one: choose dataset for transformation. 
# Step two: mutate and create new column (GDP_per_capita)
merged_data <- merged_data |> 
  mutate(
    GDP_per_capita = 1000000 * GDP/Population
    )
```

```{r}
# Creating new dataset only containing population, GDP and GDP per capita
merged_data_GDP_PC <- merged_data %>%
  select(Population, GDP, GDP_per_capita)
```

```{r}
# Summary for viewing the new dataset. 
summary(merged_data_GDP_PC) 
```

### Calculation steps

![](images/387521025_674930251254296_7967018015334033524_n.png){fig-alt="Formula of GDP per capita"}

The first step in calculating GDP per capita for each sub-region, was to merge the two datasets of GDP and population.
We named the new dataset merged_data.
Furthermore, we started with transforming the new dataset by creating a new column called GDP_per_capita.
We calculated GDP per capita by using the formula GDP divided by Population, but to view an more presentable numbers, we multiplied the formula with 1 000 000 since we want to provide GDP per capita in million EURO.
Lastly, we created a another new dataset called merged_data_GDP_PC and provided the summary function to get an overview of various summary statistics and information for each column in the merged_data_GDP_PC dataset.

## Descriptive Analysis:

Sjekk DEA dataene!!!

Beskrive metadatamangler

(Beskrive millioneuro i GDP)

Beskrive finanskrisen og Covid i grafen.

### Germany

```{r}
# Created new dataset called GDP_DE_nuts2.
# Filtered sub-regions from Germany by using str_sub to extract a substring from the Sub_regions columns containing the letters DE for Germany.
# Creating new column called id_nuts2 to save the new data for calculating Gini coefficient, for presenting the numbers of regional inequity in Germany at NUTS2 level.
# Next step is to group the numbers of NUTS2 level sorted by the the code of the region in NUTS2 level and year.
# Finally summarise the Gini coefficient numbers of each German region in NUTS2 level by multiplying 1 000 000 with GDP divided by population. 
GDP_DE_nuts2 <- merged_data %>%
  filter(
    str_sub(Sub_regions, start = 1L, end = 2L) == "DE"
  ) |> 
  mutate(
    id_nuts2 = fct(str_sub(Sub_regions, start = 1L, end = 4L))
  ) |> 
  group_by(id_nuts2, Year) %>%
  summarise(
    GDP_per_capita_nuts2_DE = sum(1000000*GDP)/sum(Population)
    ) 
```

```{r}
# Since Germany contains many regions, we have deceided to present them in two new values.
# DEz1North and DEz2SOUTH are the two values where we have devided Germany in South and North. 
DEz1NORTH <- c("DE30", "DE40", "DE50", "DE60", "DE80", "DE91", "DE92", "DE93", "DE94", "DEA1", "DEA2", "DEA3", "DEA4", "DEA5", "DEE0", "DEF0", "DEG0") 
DEz2SOUTH <- c("DE11", "DE12", "DE13", "DE14", "DE21", "DE22", "DE23", "DE24", "DE25", "DE26", "DE27", "DE71", "DE72", "DE73", "DEB1", "DEB2", "DEB3", "DEC0", "DED2", "DED4", "DED5")
```

```{r}
# First step is to place the location of the figure caption and name it.
# Secondly, we filter GDP_DE_nuts2 to contain integer starting from 3 and ending with 4. Moreover, in this dataset we only contain vales larger or equal to 0, but less than 50.
# Thirdly, we represent the data in GPD_DE_nuts2 by mapping them in a plot using ggplot, where the x-axis represents year and y-axis represents GPD_per_capita. Furthermore the colour is determined by id_nuts2.
# Fourthly, we exclude the geom_smooth and instead use geom_line since this gives a accurate description of our data from Germany.
#| cap-location: bottom
#| fig-cap: "GDP per year."
GDP_DE_nuts2 |>
  filter(
    id_nuts2 %in% DEz1
  ) |> 
  ggplot(mapping = aes(
    x = Year, 
    y = GDP_per_capita_nuts2_DE, 
    colour = id_nuts2)
    ) +
  #geom_smooth(se = FALSE, snap = 0.9)
  geom_line()
```

```{r}
GDP_DE_nuts2 |>
  filter(
    id_nuts2 %in% DEz2
  ) |> 
  ggplot(mapping = aes(
    x = Year, 
    y = GDP_per_capita_nuts2_DE, 
    colour = id_nuts2)
    ) +
  #geom_smooth(se = FALSE, snap = 0.9)
  geom_line()
```

```{r}
# Creating new dataset called desc_stat_DE_nuts2 and grouping it by year. 
# Using the summarise() function to summarize various statistics for each year. 
desc_stat_DE_nuts2 <- GDP_DE_nuts2 |> 
  group_by(Year) |> 
  summarise(
    min_GDP_each_year = min(GDP_per_capita_nuts2_DE),
    max_GDP_each_year = max(GDP_per_capita_nuts2_DE),
    median_GDP_each_year = median(GDP_per_capita_nuts2_DE),
    mean_GDP_each_year = mean(GDP_per_capita_nuts2_DE),
    sd_GDP_each_year = sd(GDP_per_capita_nuts2_DE),
    var_GDP_each_year = sd_GDP_each_year^2
  )
```

```{r}
# To ensure the table do not contain previous grouping, we use the ungroup function. Moreover, we select desirable variable. Additional, the st fuction is utilised to compute summary statistics for the selected columns. Lastly, the summ-fuction specifies the summary statistics to calculate
GDP_DE_nuts2 |> 
  ungroup() |> 
  select(Year, GDP_pc = GDP_per_capita_nuts2_DE) |> 
  st(group = "Year", group.long = TRUE, 
     summ = c('notNA(x)','mean(x)', 'median(x)', 
              'sd(x)','min(x)','max(x)'),
     )
```

```{r}
GDP_DE_nuts2 |> 
  filter(Year == 2005) |> 
  select(-Year) |> 
  st()
```

#### Description of the numbers from German sub-regions

#### 

### Finland

```{r}
GDP_FI_nuts2 <- merged_data %>%
  filter(
    str_sub(Sub_regions, start = 1L, end = 2L) == "FI"
  ) |> 
  mutate(
    id_nuts2 = str_sub(Sub_regions, start = 1L, end = 4L)
  ) |> 
  group_by(id_nuts2, Year) %>%
  summarise(
    GDP_per_capita_nuts2_FI = sum(1000000*GDP)/sum(Population)
    ) 
```

```{r}
#| cap-location: bottom
#| fig-cap: "De GNP per år."
GDP_FI_nuts2 |>
  filter(
    as.integer(str_sub(id_nuts2, start = 3L, end = 4L)) >= 0
    )  |>
  filter(
  as.integer(str_sub(id_nuts2, start = 3L, end = 4L)) < 50
  ) |> 
  ggplot(mapping = aes(
    x = Year, 
    y = GDP_per_capita_nuts2_FI, 
    colour = id_nuts2)
    ) +
  #geom_smooth(se = FALSE, snap = 0.9)
  geom_line()
```

### Romania

```{r}
GDP_RO_nuts2 <- merged_data %>%
  filter(
    str_sub(Sub_regions, start = 1L, end = 2L) == "RO"
  ) |> 
  mutate(
    id_nuts2 = str_sub(Sub_regions, start = 1L, end = 4L)
  ) |> 
  group_by(id_nuts2, Year) %>%
  summarise(
    GDP_per_capita_nuts2_RO = sum(1000000*GDP)/sum(Population)
    ) 
```

```{r}
#| cap-location: bottom
#| fig-cap: "De GNP per år."
GDP_RO_nuts2 |>
  filter(
    as.integer(str_sub(id_nuts2, start = 3L, end = 4L)) >= 0
    )  |>
  filter(
  as.integer(str_sub(id_nuts2, start = 3L, end = 4L)) < 50
  ) |> 
  ggplot(mapping = aes(
    x = Year, 
    y = GDP_per_capita_nuts2_RO, 
    colour = id_nuts2)
    ) +
  #geom_smooth(se = FALSE, snap = 0.9)
  geom_line()
```

```{r}

```

# Regional inequity

## Literature review

Regional inequality shows variation in regional GDP per capita, and according to @lessmann_and_seidel2017, regional inequality occurs when one region experiences different assumptions than other regions.
Moreover, when the level of economic development is high, there is significant regional inequality [@lessmann_and_seidel2017].
According to @williamson1965, one crucial difference that leads to regional inequality is the access to natural resources.
Regions rich in natural resources grow faster than regions in the rest of the country, which results in inequality.
Furthermore, openness is another critical element of why regional inequality occurs.
A region with more significant access to the international trade market than other regions with limited access will gain more from international trade if international trade costs decrease [@lessmann_and_seidel2017].

Moreover, openness can also contribute to foreign investors investing in a more attractive region, e.g., access to natural resources.
In the end, this led to an imbalance in regional equality.
Additionally, mobility can provide regional inequality through differences in transport costs from one region to another [@lessmann_and_seidel2017].
The differences in transport costs are caused, e.g. by fuel consumption per kilometre.
 

Furthermore, another significant element creating regional inequality is bureaucracy, policy and stability in a country [@lessmann_and_seidel2017].
Civil war affects the country's balance of regional equality and creates different assumptions.
An example is regions in a country that experience increasing aid.
Receiving assistance from foreign aid organisations creates inequality.
Lastly, @lessmann_and_seidel2017 state that an area where ethnic groups dominate as a minority can result in regional inequity.

Based on the research conducted by , considering regional inequities is essential since it can influence economic outcomes.
The research shows many examples of high- and low-income countries experiencing unbalanced regional development that results in income inequality [@lessmann_and_seidel2017].

## GINI Coefficient Calculation

```{r}
# Creating two new columns in the dataset merged_data called id_nuts2 and id_nuts0. Secondly, extracting the first four characters of the Sub_regions column and assigns it to the new id_nuts2 column, as well as the first two characters and assigns them to the new id_nuts0 column. Lastly, remove grouping. 
merged_data <- merged_data %>%
  mutate(
    id_nuts2 = substr(Sub_regions,1,4),
    id_nuts0 = substr(Sub_regions,1,2)
    ) %>%
  ungroup()
# Creating new dataset called merged_temp and group the data by id_nuts2 and Year. Use mutate to calculate a new column called gini_n2 using the gini.wtd function, which compute a weighted Gini coefficient based on GDP per capita. Finally, remove grouping. 
merged_temp <- merged_data %>%
  group_by(id_nuts2, Year) %>%
  mutate(gini_n2 = gini.wtd(GDP_per_capita)) %>%
  ungroup()
```

```{r}
# Creating two new columns called id_nuts2 and id_nuts0. Secondly, extracting the first four characters of the Sub_regions column and assigns it to the new id_nuts2 column, as well as the first two characters and assigns them to the new id_nuts0 column. Lastly, choosing columns to be retained listed within the select function.
merged_temp <- merged_temp %>%
  mutate(id_nuts2 = substr(Sub_regions, 1,4),
          id_nuts0 = substr(Sub_regions, 1,2)) %>%
  select(Year, Sub_regions, Population, GDP, GDP_per_capita, id_nuts0, id_nuts2, gini_n2)
```

To calculate the population-weighted Gini coefficient for GDP for each European NUTS2 level region within Germany, Finland and Romania, we used the data on the GDP and population for the different regions and associated countries.
The Gini coefficient measures income or wealth inequality within a population [@imf_n_d].
In this case, we want to calculate the Gini coefficient for GDP, which is a measure of economic inequality.
We calculated the Gini coefficient using the following formula:

![](images/387325388_332262946048979_5064907706589960466_n.png){fig-alt="Formula of GINI coefficient"}

We want to calculate the weighted average of the Gini coefficients based on the population of each region or country.
We do this by calculating a new column called gini_n2 using mutate, and applying the gini.wtd function, which compute a weighted Gini coefficient based on GDP per capita.

The population-weighted Gini coefficient provides a measure of economic inequality across all our regions and associated countries, taking into account their respective populations [@imfnd]. A Gini coefficient close to 0 indicates a more equal distribution of income or wealth among the population. In societies with low Gini coefficients, there is relatively less income or wealth inequality, and resources are more evenly distributed among individuals or households. These societies tend to have a larger middle class and fewer people living in poverty or extreme wealth [@imfnd]

A Gini coefficient close to 1 signifies a high level of income or wealth inequality.
In societies with high Gini coefficients, a significant portion of the income or wealth is concentrated among a small percentage of the population, leading to pronounced disparities.
These societies may have a large gap between the rich and the poor, with some individuals or households having substantially more resources than others [@imfnd].

The zero values occur as a result of regions like in Germany where the regions is actually an foreign embassy, army base or offshore energy prodution with no permanent residence.
This means they do not have any GDP per capita [@eurostat2021].

## Data presentation

## Discussion

```{r}
#| echo: false
# siste
```
